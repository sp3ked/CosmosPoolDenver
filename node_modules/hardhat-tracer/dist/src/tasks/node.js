"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const config_1 = require("hardhat/config");
const wrapper_1 = require("hardhat/internal/core/providers/wrapper");
const hre_1 = require("../extend/hre");
const utils_1 = require("../utils");
const wrapper_2 = require("../wrapper");
(0, utils_1.createTracerTask)("node").setAction(utils_1.runTask);
(0, config_1.subtask)(task_names_1.TASK_NODE_GET_PROVIDER).setAction(async (args, hre, runSuper) => {
    const baseProvider = await runSuper(args);
    const wrappedProvider = (0, wrapper_2.wrapProvider)(hre, new RpcWrapper(hre, baseProvider));
    (0, wrapper_2.wrapTracer)(hre, wrappedProvider);
    (0, hre_1.addRecorder)(hre).catch(console.error);
    return hre.network.provider;
});
class RpcWrapper extends wrapper_1.ProviderWrapper {
    constructor(hre, provider) {
        super(provider);
        this.hre = hre;
        this.provider = provider;
    }
    async request({ method, params }) {
        if (method === "tracer_lastTrace") {
            const trace = this.hre.tracer.lastTrace();
            if (trace === undefined) {
                throw new Error("No trace available");
            }
            return trace;
        }
        else if (method === "tracer_getTrace") {
            if (params && Array.isArray(params) && params.length === 1) {
                const trace = this.hre.tracer.recorder?.getTrace(params[0]);
                if (trace === undefined) {
                    throw new Error("No trace available for provided txHash");
                }
                return trace;
            }
            else {
                throw new Error("Params should be [txHash]");
            }
        }
        return this.provider.send(method, params);
    }
}
//# sourceMappingURL=node.js.map